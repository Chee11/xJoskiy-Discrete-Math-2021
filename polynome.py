def MUL_PQ_P(P, Q):
    for index in range(0, P[0]):
        P[1][index] = MUL_PQ_P(P[1][index], Q)
    return P
# Гурьянов Савелий
# Каждый коэффициент многочлена циклично умножается на переданное рациональное число


def GCF_PP_P(P1, P2):
    if DEG_P_N(P1) >= DEG_P_N(P2):
        while (DEG_P_N(P2) != 0):
            P1, P2 = P2, MOD_PP_P(P1, P2)
        return P1
    else:
        return GCF_PP_P(P2, P1)
# Гурьянов Савелий
# Реализуется алгоритм Евклида для многочленов: пока степень меньшего многочлена неотрицательна,
# в больший многочлен переписывается меньший, а в меньший - остаток от деления большего на меньший

def LED_P_Q(list0):
# Пекло Елизавета
#Нахождение старшего коэффициента многочлена
    for (i != " ") in list0:
        list1 = list1 + i
    return list1


def ADD_PP_P(x, y):
    # Кривоконь Максим
    # Сложение многочленов
    i = g = 0
    spx = ""  # Тут хранится кол-во цифр в каждом коэффициенте при Х, считая знак
    spy = ""  # Тут хранится кол-во цифр в каждом коэффициенте при Х, считая знак
    res = ""  # Результат
    prdx = []  # Тут хранятся сами коэффициенты вместе со знаком
    prdy = []  # Тут хранятся сами коэффициенты вместе со знаком
    while (i != len(x)):  # Тут считаем кол-во цифр в каждом кэффициенте первой переменной
        while (x[i] != " "):
            g = g + 1  # Кол-во цифр
            i = i + 1
            if (i == len(x)):
                break
            elif (x[i] == " "):
                i = i + 1
                break
        spx = spx + str(g)  # Записываем результат в строку
        g = 0               # и обнуляем
    i = g = 0  # Как только почтиали цифры в первой переменной тоже обнуляем
    while (i != len(y)):  # Тут считаем кол-во цифр в каждом кэффициенте второй переменной
        while (y[i] != " "):
            g = g + 1  # Кол-во цифр
            i = i + 1
            if (i == len(y)):
                break
            elif (y[i] == " "):
                i = i + 1
                break
        spy = spy + str(g)  # Записываем результат в строку
        g = 0               # и обнуляем
    if (len(spx) > len(spy)):  # Тут мы выбираем максимальную длину многочлена
        dl = len(spx)          # считая кол-во элементов в строке с цифрами
    else:
        dl = len(spy)
    i = ii = 0
    j = 0
    while (ii != dl):  # Тут мы получаем готовый список с коэффициентами первой переменной
        if (ii < len(spx)):
            prdx.insert(0, x[i:(i+int(spx[j]))])
            i = i + int(spx[j]) + 1
            j = j + 1
            ii = ii + 1
        else:
            prdx.insert(0, str("00"))  # Если кол-во коэффициентов в первой переменной меньше, чем во второй, то
            ii = ii + 1                # записываем их нулями - "00"
    prdx.reverse()
    i = ii = 0
    j = 0
    while (ii != dl):  # Тут мы получаем готовый список с коэффициентами второй переменной
        if (ii < len(spy)):
            prdy.insert(0, y[i:(i + int(spy[j]))])
            i = i + int(spy[j]) + 1
            j = j + 1
            ii = ii + 1
        else:
            prdy.insert(0, str("00"))  # Если кол-во коэффициентов во второй переменной меньше, чем в первой, то
            ii = ii + 1                # записываем их нулями - "00"
    prdy.reverse()
    i = 0
    while (i != len(prdx)):
        res = res + ADD_QQ_Q((prdx[i]+"/1"), (prdy[i]+"/1")) + " "  # Получаем итоговый результат сложения
        i = i + 1
    return res
